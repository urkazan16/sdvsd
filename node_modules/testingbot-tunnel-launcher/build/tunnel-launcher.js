'use strict';

var async = require('async');
var fs = require('fs');
var os = require('os');
var path = require('path');
var spawn = require('child_process').spawn;
var downloader = require('./downloader');
var tunnelLocation = void 0;
var activeTunnel = void 0;
var started = false;

function logger(msg) {
    console.log.apply(console, arguments);
}

function download(options, callback) {
    tunnelLocation = path.normalize(path.join(__dirname, '../testingbot-tunnel.jar'));

    var url = 'https://testingbot.com/tunnel/testingbot-tunnel.jar';

    if (options.tunnelVersion) {
        tunnelLocation = path.normalize(path.join(__dirname, '../testingbot-tunnel-' + options.tunnelVersion + '.jar'));
        url = 'https://testingbot.com/tunnel/testingbot-tunnel-' + options.tunnelVersion + '.jar';
    }

    try {
        var tunnelFile = fs.statSync(tunnelLocation);
        if (tunnelFile['size'] > 1024) {
            return callback(null);
        }
    } catch (ignore) {}

    downloader.get(url, { fileName: 'testingbot-tunnel', destination: tunnelLocation }, function (err, destination) {
        if (err) {
            return callback(new Error('Could not download the tunnel from TestingBot - please check your connection. ' + err.message));
        }

        return callback(null);
    });
}

function run(options, callback) {
    if (!fs.existsSync(tunnelLocation)) {
        return callback(new Error('Tunnel jar file is not present in ' + tunnelLocation));
    }

    var checkJava = spawn('java');
    checkJava.on('error', function (err) {
        return callback(new Error('Java might not be installed, necessary to use testingbot-tunnel ' + err.message));
    });

    var onReady = function onReady() {
        started = true;
        logger('Tunnel is ready');
        callback(null, activeTunnel);
    };

    var args = [];

    args.push('-jar');
    args.push(tunnelLocation);

    if (options.apiKey) {
        args.push(options.apiKey);
    }

    if (options.apiSecret) {
        args.push(options.apiSecret);
    }

    for (var option in options) {
        if (option === 'apiKey' || option === 'apiSecret' || option === 'verbose' || option === 'tunnelVersion') {
            continue;
        }

        if (options[option]) {
            args.push('--' + option);
            args.push(options[option]);
        } else {
            args.push('--' + option);
        }
    }

    var readyFile = path.join(os.tmpdir(), 'testingbot.ready');
    try {
        if (fs.statSync(readyFile).isFile()) {
            logger('Tunnel Readyfile already exists, removing');
            fs.unlinkSync(readyFile);
        }
    } catch (ignore) {}

    args.push('-f');
    args.push(readyFile);

    var readyFileChecker = setInterval(function () {
        fs.stat(readyFile, function (error, stat) {
            if (!error) {
                clearInterval(readyFileChecker);
                onReady();
            }
        });
    }, 800);

    if (options.verbose) {
        logger('Starting tunnel with options', args);
    }
    activeTunnel = spawn('java', args, {});

    activeTunnel.stderr.on('data', function (data) {
        data = data.toString().trim();
        if (options.verbose && data !== '') {
            logger(data);
        }
        if (data.indexOf('is available for download') > -1) {
            logger(data);
        }
        if (data.indexOf('error code : 401') > -1) {
            activeTunnel.error = 'Invalid credentials. Please supply the correct key/secret obtained from TestingBot.com';
            activeTunnel.close();
        }
    });

    activeTunnel.stdout.on('data', function (data) {
        data = data.toString().trim();
        if (options.verbose && data !== '') {
            logger(data);
        }
    });

    activeTunnel.close = function (closeCallback) {
        if (closeCallback) {
            if (!activeTunnel) {
                closeCallback();
            } else {
                activeTunnel.on('close', function () {
                    closeCallback();
                });
            }
        }
        activeTunnel.kill('SIGINT');
    };

    activeTunnel.on('exit', function (code, signal) {
        logger('Closing TestingBot Tunnel');
        if (!started) {
            callback(new Error(activeTunnel.error ? activeTunnel.error : 'Could not start TestingBot Tunnel. Exit code ' + code + ' signal: ' + signal));
        }

        started = false;
        activeTunnel = null;
    });
}

function killTunnel(callback) {
    if (!callback) {
        callback = function callback() {};
    }

    if (!activeTunnel) {
        return callback(new Error('no active tunnel'));
    }

    activeTunnel.kill('SIGINT');
    callback(null);
}

function downloadAndRun(options, callback) {
    if (!options) {
        options = {};
    }

    if (!callback) {
        callback = function callback() {};
    }

    async.waterfall([async.apply(download, options), async.apply(run, options)], callback);
}

module.exports = downloadAndRun;
module.exports.kill = killTunnel;