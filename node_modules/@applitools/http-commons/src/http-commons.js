'use strict'
const {promisify: p} = require('util')
const {URL} = require('url')
const net = require('net')
const dns = require('dns')
const fetch = require('node-fetch').default
const Agent = require('agentkeepalive')
const HttpsAgent = require('agentkeepalive').HttpsAgent
const merge = require('lodash.merge')
const debug = require('debug')('applitools:http-commons:fetch')
const {makeTiming} = require('@applitools/monitoring-commons')
const {cacheFunctionSync} = require('@applitools/functional-commons')
const retryFetch = require('./retryFetch')

const dnsCache = new Map()
const EXPIRATION_DELTA_MS = 5 * 60 * 1000

const ENABLE_DNS_CACHING = !!process.env.ENABLE_DNS_CACHING
if (ENABLE_DNS_CACHING) {
  console.log('enabling DNS caching...')
}

const HTTP_FETCH_SOCKET_TIMEOUT = parseInt(process.env.HTTP_FETCH_SOCKET_TIMEOUT, 10) || 30000

const SOCKET_OPTIONS = {keepAlive: true, maxSockets: 512, timeout: HTTP_FETCH_SOCKET_TIMEOUT}
const defaultAgent = cacheFunctionSync(protocol =>
  protocol === 'http:' ? new Agent(SOCKET_OPTIONS) : new HttpsAgent(SOCKET_OPTIONS),
)

async function throwErrorFromBadStatus(url, response) {
  const body = await response.text().catch(() => `failed to get body of error`)

  const err = new Error(`Response ${response.status} returned from ${url}, body: ${body}`)
  err.code = 'ERR_X_STATUS_CODE_NOT_OK'
  err.status = response.status
  err.statusText = response.statusText
  err.headers = response.headers.raw()
  err.body = body

  throw err
}

/**
 *
 * @param {string | URL} url
 * @param {import('node-fetch').RequestInit} [fetchOptions]
 * @param {{alternativeFetch?: import('node-fetch').default}} [options]
 * @returns {Promise<Buffer>}
 */
async function fetchAsBuffer(url, fetchOptions, {alternativeFetch} = {}) {
  return await debugPerformance(url, async parentPerformance => {
    const {timeItAsync} = makeTiming({parentPerformance})
    const finalFetch = alternativeFetch || fetch
    const response = await fetchBySubstituteDnsNameWithIp(
      finalFetch,
      url,
      fetchOptions,
      parentPerformance,
    )

    if (!response.ok) await throwErrorFromBadStatus(url, response)

    return await timeItAsync('body', () => response.buffer())
  })
}

/**
 * @param {string | URL} url
 * @param {import('node-fetch').RequestInit} [fetchOptions]
 * @param {{alternativeFetch?: import('node-fetch').default}} [options]
 * @returns {Promise<object>}
 */
async function fetchAsJson(url, fetchOptions, {alternativeFetch} = {}) {
  return await debugPerformance(url, async parentPerformance => {
    const {timeItAsync} = makeTiming({parentPerformance})
    const finalFetch = alternativeFetch || fetch
    const response = await fetchBySubstituteDnsNameWithIp(
      finalFetch,
      url,
      fetchOptions,
      parentPerformance,
    )

    if (!response.ok) await throwErrorFromBadStatus(url, response)

    return await timeItAsync('body', () => response.json())
  })
}

/**
 * @param {string | URL} url
 * @param {import('node-fetch').RequestInit} [fetchOptions]
 * @param {{alternativeFetch?: import('node-fetch').default}} [options]
 * @returns {Promise<string>}
 */
async function fetchAsText(url, fetchOptions, {alternativeFetch} = {}) {
  return await debugPerformance(url, async parentPerformance => {
    const {timeItAsync} = makeTiming({parentPerformance})
    const finalFetch = alternativeFetch || fetch
    const response = await fetchBySubstituteDnsNameWithIp(
      finalFetch,
      url,
      fetchOptions,
      parentPerformance,
    )

    if (!response.ok) await throwErrorFromBadStatus(url, response)

    return await timeItAsync('body', () => response.text())
  })
}

/**
 * @param {string | URL} url
 * @param {object} json
 * @param {import('node-fetch').RequestInit} [fetchOptions]
 * @param {{alternativeFetch?: import('node-fetch').default}} [options]
 * @returns {Promise<string>}
 */
async function fetchAsTextWithJsonBody(url, json, fetchOptions, {alternativeFetch} = {}) {
  return await debugPerformance(url, async parentPerformance => {
    const {timeItAsync} = makeTiming({parentPerformance})
    const finalFetch = alternativeFetch || fetch
    const response = await fetchBySubstituteDnsNameWithIp(
      finalFetch,
      url,
      merge(
        {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(json)},
        fetchOptions || {},
      ),
      parentPerformance,
    )

    if (!response.ok) await throwErrorFromBadStatus(url, response)

    return await timeItAsync('body', () => response.text())
  })
}

/**
 * @param {string | URL} url
 * @param {object} json
 * @param {import('node-fetch').RequestInit} [fetchOptions]
 * @param {{alternativeFetch?: import('node-fetch').default}} [options]
 * @returns {Promise<Buffer>}
 */
async function fetchAsBufferWithJsonBody(url, json, fetchOptions, {alternativeFetch} = {}) {
  return await debugPerformance(url, async parentPerformance => {
    const {timeItAsync} = makeTiming({parentPerformance})
    const finalFetch = alternativeFetch || fetch
    const response = await fetchBySubstituteDnsNameWithIp(
      finalFetch,
      url,
      merge(
        {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(json)},
        fetchOptions || {},
      ),
      parentPerformance,
    )

    if (!response.ok) await throwErrorFromBadStatus(url, response)

    return await timeItAsync('body', () => response.buffer())
  })
}

/**
 * @param {string | URL} url
 * @param {object} json
 * @param {import('node-fetch').RequestInit} [fetchOptions]
 * @param {{alternativeFetch?: import('node-fetch').default}} [options]
 * @returns {Promise<object>}
 */
async function fetchAsJsonWithJsonBody(url, json, fetchOptions, {alternativeFetch} = {}) {
  return await debugPerformance(url, async parentPerformance => {
    const {timeItAsync} = makeTiming({parentPerformance})
    const finalFetch = alternativeFetch || fetch
    const response = await fetchBySubstituteDnsNameWithIp(
      finalFetch,
      url,
      merge(
        {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(json)},
        fetchOptions || {},
      ),
      parentPerformance,
    )

    if (!response.ok) await throwErrorFromBadStatus(url, response)

    return await timeItAsync('body', () => response.json())
  })
}

async function fetchWithIp(url, fetchOptions = undefined) {
  return await debugPerformance(url, async parentPerformance => {
    return await fetchBySubstituteDnsNameWithIp(fetch, url, fetchOptions, parentPerformance)
  })
}

let TEST_ignoreHostResolutions = undefined

async function TEST_setHostsMockedInTests(hosts) {
  TEST_ignoreHostResolutions = new Set(hosts)
}

/**
 *
 *
 * @param {import('node-fetch').default} fetch
 * @param {string | URL} url
 * @param {import('node-fetch').RequestInit} fetchOptions
 * @param {any} parentPerformance
 * @returns
 */
async function fetchBySubstituteDnsNameWithIp(fetch, url, fetchOptions, parentPerformance) {
  const {timeItAsync} = makeTiming({parentPerformance})

  const u = new URL(url)

  const fetchOptionsWithAgent = Object.assign({}, {agent: defaultAgent(u.protocol)}, fetchOptions)

  if (!ENABLE_DNS_CACHING) {
    return await timeItAsync('headers', () => fetch(u.href, fetchOptionsWithAgent))
  }

  const host = u.hostname

  if (net.isIP(host) || (TEST_ignoreHostResolutions && TEST_ignoreHostResolutions.has(host))) {
    return await timeItAsync('headers', () => fetch(u.href, fetchOptionsWithAgent))
  }

  const newFetchOptions = replaceHostHeader(fetchOptionsWithAgent, host)

  const cachedIpAndExpiration = dnsCache.get(host)

  if (cachedIpAndExpiration) {
    if (cachedIpAndExpiration.expiration >= Date.now()) {
      u.hostname = cachedIpAndExpiration.ip

      return await timeItAsync('headers', () => fetch(u.href, newFetchOptions))
    }
  }

  const {address} = await timeItAsync('dns-resolve', () => p(dns.lookup)(host))

  dnsCache.set(host, {ip: address, expiration: Date.now() + EXPIRATION_DELTA_MS})

  u.hostname = address

  return await timeItAsync('headers', () => fetch(u.href, newFetchOptions))
}

/**
 *
 *
 * @param {import('node-fetch').RequestInit} fetchOptions
 * @param {string} host
 * @returns {import('node-fetch').RequestInit}
 */
function replaceHostHeader(fetchOptions, host) {
  if (!fetchOptions || !fetchOptions.headers) {
    return merge(fetchOptions, {headers: {Host: host}})
  }
  if (Object.keys(fetchOptions.headers).every(key => key.toLowerCase() != 'host')) {
    return merge(fetchOptions, {headers: {Host: host}})
  } else {
    return fetchOptions
  }
}
/**
 *
 * @template T
 * @param {string | URL} url
 * @param {(performance:object)=>Promise<T>} f
 * @returns {Promise<T>}
 */
async function debugPerformance(url, f) {
  const performance = {}
  try {
    return await f(performance)
  } finally {
    debug('performance for url %s: %o', url, performance)
  }
}

function appendQueryParams(baseUrl, queryParams) {
  const url = new URL(baseUrl)
  for (const param of Object.keys(queryParams)) {
    url.searchParams.set(param, queryParams[param])
  }
  return url.toString()
}

module.exports = {
  appendQueryParams,
  fetchAsBuffer,
  fetchAsJson,
  fetchAsText,
  fetchAsTextWithJsonBody,
  fetchAsBufferWithJsonBody,
  fetchAsJsonWithJsonBody,
  fetch: fetchWithIp,
  retryFetch,
  TEST_setHostsMockedInTests,
}
