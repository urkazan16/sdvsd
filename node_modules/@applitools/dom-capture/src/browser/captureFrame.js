'use strict';
const defaultDomProps = require('./defaultDomProps');
const getBackgroundImageUrl = require('./getBackgroundImageUrl');
const getImageSizes = require('./getImageSizes');
const genXpath = require('./genXpath');
const absolutizeUrl = require('./absolutizeUrl');
const makeGetBundledCssFromCssText = require('./getBundledCssFromCssText');
const parseCss = require('./parseCss');
const makeFetchCss = require('./fetchCss');
const makeExtractCssFromNode = require('./extractCssFromNode');
const makeCaptureNodeCss = require('./captureNodeCss');
const NODE_TYPES = {
  ELEMENT: 1,
  TEXT: 3,
};
const API_VERSION = '1.0.0';

async function captureFrame(
  {styleProps, rectProps, ignoredTagNames} = defaultDomProps,
  doc = document,
) {
  const start = Date.now();
  const unfetchedResources = new Set();
  const iframeCors = [];
  const iframeToken = '@@@@@';
  const unfetchedToken = '#####';
  const separator = '-----';

  const fetchCss = makeFetchCss(fetch);
  const getBundledCssFromCssText = makeGetBundledCssFromCssText({
    parseCss,
    CSSImportRule,
    fetchCss,
    absolutizeUrl,
    unfetchedToken,
  });
  const extractCssFromNode = makeExtractCssFromNode({fetchCss, absolutizeUrl});
  const captureNodeCss = makeCaptureNodeCss({
    extractCssFromNode,
    getBundledCssFromCssText,
    unfetchedToken,
  });

  // Note: Change the API_VERSION when changing json structure.
  const capturedFrame = await doCaptureFrame(doc);
  capturedFrame.version = API_VERSION;

  const iframePrefix = iframeCors.length ? `${iframeCors.join('\n')}\n` : '';
  const unfetchedPrefix = unfetchedResources.size
    ? `${Array.from(unfetchedResources).join('\n')}\n`
    : '';
  const metaPrefix = JSON.stringify({
    separator,
    cssStartToken: unfetchedToken,
    cssEndToken: unfetchedToken,
    iframeStartToken: `"${iframeToken}`,
    iframeEndToken: `${iframeToken}"`,
  });
  const ret = `${metaPrefix}\n${unfetchedPrefix}${separator}\n${iframePrefix}${separator}\n${JSON.stringify(
    capturedFrame,
  )}`;
  console.log('[captureFrame]', Date.now() - start);
  return ret;

  function filter(x) {
    return !!x;
  }

  function notEmptyObj(obj) {
    return Object.keys(obj).length ? obj : undefined;
  }

  function captureTextNode(node) {
    return {
      tagName: '#text',
      text: node.textContent,
    };
  }

  async function doCaptureFrame(frameDoc) {
    const bgImages = new Set();
    let bundledCss = '';
    const ret = await captureNode(frameDoc.documentElement);
    ret.css = bundledCss;
    ret.images = await getImageSizes({bgImages});
    return ret;

    async function captureNode(node) {
      const {bundledCss: nodeCss, unfetchedResources: nodeUnfetched} = await captureNodeCss(
        node,
        frameDoc.location.href,
      );
      bundledCss += nodeCss;
      if (nodeUnfetched) for (const elem of nodeUnfetched) unfetchedResources.add(elem);

      switch (node.nodeType) {
        case NODE_TYPES.TEXT: {
          return captureTextNode(node);
        }
        case NODE_TYPES.ELEMENT: {
          const tagName = node.tagName.toUpperCase();
          if (tagName === 'IFRAME') {
            return await iframeToJSON(node);
          } else {
            return await await elementToJSON(node);
          }
        }
        default: {
          return null;
        }
      }
    }

    async function elementToJSON(el) {
      const childNodes = (await Promise.all(
        Array.prototype.map.call(el.childNodes, captureNode),
      )).filter(filter);

      const tagName = el.tagName.toUpperCase();
      if (ignoredTagNames.indexOf(tagName) > -1) return null;

      const computedStyle = window.getComputedStyle(el);
      const boundingClientRect = el.getBoundingClientRect();

      const style = {};
      for (const p of styleProps) style[p] = computedStyle.getPropertyValue(p);

      const rect = {};
      for (const p of rectProps) rect[p] = boundingClientRect[p];

      const attributes = Array.from(el.attributes)
        .map(a => ({key: a.name, value: a.value}))
        .reduce((obj, attr) => {
          obj[attr.key] = attr.value;
          return obj;
        }, {});

      const bgImage = getBackgroundImageUrl(computedStyle.getPropertyValue('background-image'));
      if (bgImage) {
        bgImages.add(bgImage);
      }

      return {
        tagName,
        style: notEmptyObj(style),
        rect: notEmptyObj(rect),
        attributes: notEmptyObj(attributes),
        childNodes,
      };
    }

    async function iframeToJSON(el) {
      const obj = await elementToJSON(el);
      let doc;
      try {
        doc = el.contentDocument;
      } catch (ex) {
        markFrameAsCors();
        return obj;
      }
      try {
        if (doc) {
          obj.childNodes = [await doCaptureFrame(el.contentDocument)];
        } else {
          markFrameAsCors();
        }
      } catch (ex) {
        console.log('error in iframeToJSON', ex);
      }
      return obj;

      function markFrameAsCors() {
        const xpath = genXpath(el);
        iframeCors.push(xpath);
        obj.childNodes = [`${iframeToken}${xpath}${iframeToken}`];
      }
    }
  }
}

module.exports = captureFrame;
